/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package  com.longame.utils{	import flash.geom.Point;	/**	 * MathUtil Class	 * 	 * @author Sascha Balkau	 * @version 1.0.0	 */	public class MathUtil	{		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////				private static const COEFFICIENT1:Number		= Math.PI / 4;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Rounds the specified value. By default the value is rounded to the nearest		 * integer. Specifying a decimals parameter allows to round to the nearest of a		 * specified interval.		 * 		 * @param value the number to round.		 * @param decimals the number of decimal places to round the number.		 * @return the number rounded to the nearest interval.		 * 		 * @example		 * <pre>		 *     trace(MathUtil.round(3.14159, 2)); // Traces 3.14		 *     trace(MathUtil.round(3.14159, 3)); // Traces 3.142		 * </pre>		 */		public static function round(value:Number, decimals:int = 0):Number		{			var p:Number = Math.pow(10, decimals);			return Math.round(value * p) / p;		}						/**		 * Returns the floor part of the specified value. By default the integer part		 * of the number is returned just as if calling Math.floor(). However, by		 * a decimals argument, non-integer floor parts to the nearest of the specified		 * decimals interval can be returned.		 * 		 * @param value the number for which the floor part should be returned.		 * @param decimals the number of decimal places to get the floor part of the number.		 * @return the floor part of the number.		 */		public static function floor(value:Number, decimals:int = 0):Number		{			var p:Number = Math.pow(10, decimals);			return Math.floor(value * p) / p;		}						/**		 * Returns the ceiling part of the specified value. By default the next highested		 * integer number is returned just as if calling Math.ceil(). However, by specifying		 * a decimals argument, non-integer ceiling parts to the nearest of the specified		 * decimals interval can be returned.		 * 		 * @param value the number for which the ceiling part should be returned.		 * @param decimals the number of decimal places to get the ceiling part of the number.		 * @return the ceiling part of the number.		 */		public static function ceil(value:Number, decimals:int = 0):Number		{			var p:Number = Math.pow(10, decimals);			return Math.ceil(value * p) / p;		}						/**		 * Evaluates val1 and val2 and returns the smaller value. Unlike Math.min this		 * method will return the defined value if the other value is null or not a number.		 * 		 * @param val1 a value to compare.		 * @param val2 a value to compare.		 * @return Returns the smallest value, or the value out of the two that		 *          is defined and valid.		 * 		 * @example		 * <pre>		 *     trace(NumberUtil.min(5, null)); // Traces 5		 *     trace(NumberUtil.min(5, "Hexagon")); // Traces 5		 *     trace(NumberUtil.min(5, 13)); // Traces 5		 * </pre>		 */		public static function min(val1:*, val2:*):Number 		{			if (isNaN(val1) && isNaN(val2) || val1 == null && val2 == null) return NaN;			if (val1 == null || val2 == null) return (val2 == null) ? val1 : val2;			if (isNaN(val1) || isNaN(val2)) return isNaN(val2) ? val1 : val2;			return Math.min(val1, val2);		}						/**		 * Evaluates val1 and val2 and returns the larger value. Unlike Math.max this		 * method will return the defined value if the other value is null or not a number.		 * 		 * @param val1: A value to compare.		 * @param val2: A value to compare.		 * @return Returns the largest value, or the value out of the two that		 *          is defined and valid.		 * 		 * @example		 * <pre>		 *     trace(NumberUtil.max(-5, null)); // Traces -5		 *     trace(NumberUtil.max(-5, "Hexagon")); // Traces -5		 *     trace(NumberUtil.max(-5, -13)); // Traces -5		 * </pre>		 */		public static function max(val1:*, val2:*):Number 		{			if (isNaN(val1) && isNaN(val2) || val1 == null && val2 == null) return NaN;			if (val1 == null || val2 == null) return (val2 == null) ? val1 : val2;			if (isNaN(val1) || isNaN(val2)) return (isNaN(val2)) ? val1 : val2;			return Math.max(val1, val2);		}						/**		 * A faster version of Math.sqrt. Computes and returns the square root of		 * the specified number.		 * 		 * @param val A number greater than or equal to 0.		 * @return If the parameter val is greater than or equal to zero, a number;		 *          otherwise NaN (not a number).		 */		public static function sqrt(val:Number):Number		{			if (isNaN(val)) return NaN;			if (val == 0) return 0;						var thres:Number = 0.002;			var b:Number = val * 0.25;			var a:Number;			var c:Number;						do			{				c = val / b;				b = (b + c) * 0.5;				a = b - c;				if (a < 0) a = -a;			}			while (a > thres);						return b;		}						/**		 * A faster (but much less accurate) version of Math.atan2(). For close range/loose		 * comparisons this works very well, but avoid for long-distance or high accuracy		 * simulations.<p>		 * Computes and returns the angle of the point y/x in radians, when measured		 * counterclockwise from a circle's x axis (where 0,0 represents the center of the		 * circle). The return value is between positive pi and negative pi. Note that the		 * first parameter to atan2 is always the y coordinate.		 * 		 * @param y The y coordinate of the point.		 * @param x The x coordinate of the point.		 * @return The angle of the point x/y in radians.		 */		public static function atan2(y:Number, x:Number):Number		{			var absY:Number = y;			var coefficient2:Number = 3 * COEFFICIENT1;			var r:Number;			var angle:Number;						if (absY < 0) absY = -absY;			if (x >= 0)			{				r = (x - absY) / (x + absY);				angle = COEFFICIENT1 - COEFFICIENT1 * r;			}			else			{				r = (x + absY) / (absY - x);				angle = coefficient2 - COEFFICIENT1 * r;			}    			return (y < 0) ? -angle : angle;		}						/**		 * Experimental - Much faster version of v % d only for when d is any power of 2.		 * 		 * @param value The amount to divide.		 * @param divisor The divisor, must be a power of 2.		 * @return The remainder.		 */		public static function powerOf2Mod(value:int, divisor:int):int		{			return value & (divisor - 1);		}						/**		 * Calculates the percentage of the specified value in relation to the total.		 * 		 * @example		 * <p><pre>		 *	var totalHeight:int = 118;		 *	var currentHeight:int = 41;		 *	var currentHeightPercent:Number = MathUtil.toPercent(currentHeight, totalHeight);		 *	trace(currentHeightPercent); // 34.74576271186441		 * </pre>		 * 		 * @param value The value of which to calculate the percentage.		 * @param total The total value.		 * @return The calculated percentage of the value.		 */		public static function toPercent(value:Number, total:Number):Number		{			return (value / total) * 100;		}						/**		 * Calculates the value of the specified percentage in relation to the total.		 * 		 * @example		 * <p><pre>		 *  var totalHeight:int = 118;		 *	var currentHeightPercent:int = 34;		 *	var currentHeight:Number = MathUtil.fromPercent(currentHeightPercent, totalHeight);		 *	trace(currentHeight); // 40.120000000000005		 * </pre>		 * 		 * @param percent The percent of which to calculate the value.		 * @param total The total value.		 * @return The calculated value of the percent.		 */		public static function fromPercent(percent:Number, total:Number):Number		{			return total * (percent / 100);		}		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		private static const RADTODEG:Number		= 180 / Math.PI;		/** @private */		private static const DEGTORAD:Number		= Math.PI / 180;		/**		 * Converts a number from degrees to radians.		 * 		 * @example		 * <listing>		 * MathUtil.degreesToRadians(50);		 * </listing>		 * 		 * @param d		degree.		 * @return Number.		 */		public static function degreesToRadians(d:Number):Number 		{			return d * DEGTORAD;		}				/**		 * Converts a number from radians to degrees.		 * 		 * @example		 * <listing>		 * MathUtil.radiansToDegrees(50);		 * </listing>		 * 		 * @param r		radian.		 * @return Number.		 */		public static function radiansToDegrees(r:Number):Number 		{			return r * RADTODEG;		}				/**		 * Calculates a random number within a minimum and maximum range. Specifying a roundToInterval, ceilings the interval.		 * 		 * @example		 * <listing>		 * MathUtil.random(0, 5, 1);		 * </listing>		 * 		 * @param min		value for the bottom range.		 * @param max		value for the upper range.		 * @return	Number.		 */		public static function random(min:Number = 0, max:Number = 0, roundToInterval:Number = 1):Number		{				// If the minimum is greater than the maximum, switch the two.			if(min > max)			{				var temp:Number = min;				min = max;				max = temp;			}						// Calculate the range by subtracting the minimum from the maximum. Add 1 times the round to interval to ensure even distribution.			var deltaRange:Number = (max - min) - roundToInterval;						// Multiply the range by Math.random(). Generates a random number in the range, it won't be offset properly, nor will it be rounded to the correct number of places.			var randomNumber:Number = Math.random() * deltaRange;						// Add the minimum to the random offset to generate a random number in the correct range.			randomNumber += min;						// Return the random value. Use the custom floor() method to ensure the result is rounded to the proper number of decimal places.			return round(randomNumber, roundToInterval);		}				/**		 * This crazy little algorithm will return an array of consecutive random numbers in a given set.		 * For example if we give a min of 0 and a max of 20 and we want an array of 10 integers  we would get something back like this: [2,4,5,6,7,12,13,15,16,19]		 * The numbers will be consecutive and will not repeat. This was invented by Donald Knuth in the 70's. Sexy eh?		 *		 * @example		 * <listing>		 * MathUtil.knuthArray(0, 5, 1);		 * </listing>		 * 		 * @param	min			minimum number		 * @param	max			maximum number		 * @param	select		number of integers we wish to return inside the array, the length of the desired array.		 * @return	Array.		 */		public static function knuthArray(min:Number, max:Number, select:Number):Array		{			var array:Array = [];			var M:Number = max;			var N:Number = select;						for (var i:Number = min; i < M && N > min; ++i)			{				if(random(M - i) < N)				{					array.push(i);					N--;				}			}						return array;		}				/**		 * Calculates the factorial of the passed-in number.		 * 		 * @example		 * <listing>		 * MathUtil.factorial(50);		 * </listing>		 * 		 * @param number	the number to calculate the factorial.		 * @return Number.		 */		public static function factorial(number:Number):Number		{			if (number == 0) return 1;			var n:Number = number;			var l:Number = n - 1;			while(l)			{				n = n * l;				l--;			}			return n;		}					/**		 * Rips through an indexed array of numbers adding the total of all values.		 * 		 * @example		 * <listing>		 * MathUtil.sums([ 50, 30, 20 ]);		 * </listing>		 * 		 * @param nums		an indexed array of numbers.		 * @return Number.		 */		public static function sums(nums:Array):Number		{			var sum:Number = 0;			var numL:Number = nums.length;			for(var i:Number = 0; i < numL; i++) sum += Number(nums[ i ]);			return sum;		}				/**		 * Report the average of an indexed array of numbers.		 * 		 * @example		 * <listing>		 * MathUtil.average([ 50, 30, 20 ]);		 * </listing>		 * 		 * @param nums		an indexed array of numbers.		 * @return Number.		 */		public static function average(nums:Array):Number		{			return sums(nums) / nums.length;		}				/**		 * Checks if the passed-in integer is odd.		 * 		 * @example		 * <listing>		 * MathUtil.isOdd(23);		 * </listing>		 * 		 * @param n			the integer to check		 * @return Boolean.		 */		public static function isOdd(n:Number):Boolean		{			return Boolean(n % 2);		}				/**		 * Checks if the passed-in integer is even.		 * 		 * @example		 * <listing>		 * MathUtil.isOdd(22);		 * </listing>		 * 		 * @param n			the integer to check		 * @return Boolean.		 */			public static function isEven(n:Number):Boolean		{			return (n % 2 == 0);		}				/**		 * Checks if the passed-in number is a prime. 		 * A prime number is a positive integer that has no positive integer 		 * divisors other than 1 and itself.		 * 		 * @example		 * <listing>		 * MathUtil.isPrime(22);		 * </listing>		 * 		 * @param n			the number to check.		 * @return Boolean.		 */			public static function isPrime(n:Number):Boolean		{			if(n == 1) return false;			if(n == 2) return true;			if(n % 2 == 0) return false;			for (var i:Number = 3, e:Number = Math.sqrt(n); i <= e; i += 2) if (n % i == 0) return false;			return true;		}				/**		 * Calculates the length of the unknown side of a right triangle, by supplying the 4 points 		 * that make up the 2 sides. This is the Pythagorean Theorem.		 *			 * @example		 * <listing>		 * MathUtil.getHypotenuse(0, 5, 5, 0);		 * </listing>		 * 		 *	@param x1		the x1 point coordinate.		 *	@param x2		the x2 point coordinate.		 *	@param y1		the y1 point coordinate.		 *	@param y2		the y2 point coordinate.		 *	@return	Number.		 */		public static function getHypotenuse(x1:Number, x2:Number, y1:Number, y2:Number):Number		{			return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));		}				/**		 * Format the time.		 * 		 * @example		 * <listing>		 * MathUtil.formatTime(250);		 * </listing>		 * 		 * @param timeInSeconds		Number.		 * @return String.		 */		public static function formatTime(timeInSeconds:Number):String		{			if((!timeInSeconds) || isNaN(timeInSeconds)) return "00:00";			else			{				var minutes:String = Math.floor(timeInSeconds/60).toString();				var seconds:String = Math.ceil(timeInSeconds % 60).toString();								if(minutes.length == 1) { minutes = "0"+minutes; }				if(seconds.length == 1) { seconds = "0"+seconds; }								return (minutes+":"+ seconds);			}		}					/**		 * Returns the distance of the line between the two specified point objects		 * startPoint and endPoint.		 * 		 * @param p0 the starting coordinate of the line which distance		 *         is to be calculated.		 * @param p1 the end coordinate of the line which distance is to be		 *         calculated.		 * @return a number containing the calculate distance.		 */		public static function getDistanceByPoint(p0:Point, p1:Point):Number		{			return getDistance(p0.x,p0.y,p1.x,p1.y);		}				public static function getDistance(x0:Number,y0:Number,x1:Number,y1:Number):Number		{			var x:Number = x1-x0;			var y:Number =y1-y0;			return Math.sqrt((x * x) + (y * y));					}		/**		 * Determines the angle/degree between the first and second point.		 * 		 * @param first The first Point.		 * @param second The second Point.		 * @return The degree between the two points.		 */		public static function getAngle(first:Point, second:Point):Number		{			return Math.atan((first.y - second.y) / (first.x - second.x)) / DEGTORAD;		}	}}