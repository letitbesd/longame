package com.longame.utils{	import com.longame.utils.debug.Logger;
	
	import flash.display.DisplayObjectContainer;
	import flash.utils.ByteArray;
	/**	 * Provides utility methods for working with Objects.	 * 	 * @author longyangxi	 * @version 1.0.0	 */	public class ObjectUtil	{		////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a Vector comprised of all the keys in an Object.		 * 		 * @param obj Object in which to find keys.		 * @return Vector containing all the string key names.		 */		public static function getKeys(obj:Object):Vector.<String>		{			var keys:Vector.<String> = new Vector.<String>();			for (var k:String in obj)			{				keys.push(k);			}			return keys;		}						/**		 * Searches the first level properties of an object for another object.		 * 		 * @param obj Object to search in.		 * @param member Object to search for.		 * @return Returns true if object was found; otherwise false.		 */		public static function contains(obj:Object, member:Object):Boolean		{			for (var p:String in obj)			{				if (obj[p] == member) return true;			}			return false;		}						/**		 * Uses a ByteArray to make a clone of the specified Object. References		 * to/from the object will not be cloned.		 * 		 * @param obj Object to make the clone of.		 * @return a duplicate Object.		 * 		 * @example		 * <pre>		 *     author = new Person();		 *     author.name = "Giles";		 *     registerClassAlias("Person", Person);		 *     var clone:Person = Person(ObjectUtil.clone(author));		 *     trace(clone.name);		 * </pre>		 */		public static function clone(obj:Object):Object		{			var b:ByteArray = new ByteArray();			b.writeObject(obj);			b.position = 0;			return b.readObject();		}		/**		 * 将source的所有属性复制到target上		 * @param source:要复制的源头		 * @param target:要赋值的对象		 * @param excluded:不希望复制的字段,如["id","name"]		 * */		public static function cloneProperties(source:Object,target:Object,excluded:Array=null):void		{			var cls:Class=Reflection.getClass(source);			//普通的object获取属性名不一样			var props:Array=[];			if(cls==Object){				for(var key:* in source){					props.push({name:key,type:""});				}			}else{				props=Reflection.getVariables(source);			}			var prop:*;			for each( prop in props )			{				if(excluded&&excluded.length&&(excluded.indexOf(prop.name)>=0)) continue;				try{					StringParser.toTarget(target,prop.name,source[ prop.name ]);				}catch(e:Error){					continue;				}								}		}		public static function isSimple(value:Object):Boolean		{			var type:String = typeof(value);			switch (type)			{				case "number":				case "string":				case "boolean":				{					return true;				}									case "object":				{					return (value is Date) || (value is Array);				}			}						return false;		}						/**		 * Determines if the specified object contains no value(s).		 * 		 * @param obj Object to determine if empty.		 * @return true if object is empty; otherwise false.		 * 		 * @example		 * <pre>		 *     var testNumber:Number;		 *     var testArray:Array = [];		 *     var testString:String = "";		 *     var testObject:Object = {};		 *     trace(ObjectUtil.isEmpty(testNumber)); // traces "true"		 *     trace(ObjectUtil.isEmpty(testArray)); // traces "true"		 *     trace(ObjectUtil.isEmpty(testString)); // traces "true"		 *     trace(ObjectUtil.isEmpty(testObject)); // traces "true"		 * </pre>		 */		public static function isEmpty(obj:*):Boolean		{			if (obj == undefined) return true;			if (obj is Number) return isNaN(obj);			if (obj is Array) return (obj as Array).length == 0;			if (obj is String) return (obj as String).length == 0;						if (obj is Object)			{				for (var p:String in obj)				{					return false;				}				return true;			}						return false;			p = p; // To prevent unused local var warning!		}		/**		 * Parse's an object into the correct format for actionscript.		 * 		 * @param 	object		object from the style sheet, ex. 'blue'.		 */		public static function parseObject(object:Object = null):Object		{			// Rip through the current object and determine what to do.			for(var it:String in object)			{								if(object[it] is String) {										var str:String = object[it] as String;										var singleQuote:Boolean = StringUtil.startsWith(str, "'");					var doubleQuote:Boolean = StringUtil.startsWith(str, '"');										// String with single quotes or double quotes.					if(singleQuote == true || doubleQuote == true) {						str = StringUtil.trimCharacters(str);					}else{						var num:Number = StringUtil.parseStyleNumberString(str);						if(num) object[it] = num;					}									}							}						// Return the modified object			return object;		}						/**		 * Concatinates the properties of one object/array to another. 		 * If you wish to only overwrite a small set of properties you can set vOverwrite to true and list all of the properties you do not want to overwrite in vSkip. 		 * Conversly, if it is only two or three properties you want to set just set them item by item without using this function. 		 * As this spits out an object, you will have to cast your return as an array if you wish to concatinate arrays.		 * 		 * @param master		the object to which you wish to add properties.		 * @param slave			the object from which you wish to transfer properties to master.		 * @param overwrite		[Optional] true = overwrite properties on the master if they exist on the slave // false (default) = no not overwrite properties on the master.		 * @param skip			[Optional] list of properties as strings to ignore (ie. will not be added from slave to master).		 * @return Object.		 * @use	   {@code var concat:Object = ObjectUtil.concat(myObject, herObject, false, [ "id", "area" ]);}		 */		public static function concat(master:Object, slave:Object, overwrite:Boolean = false, skip:Array = null):Object		{			if(!skip) skip = [];						// If strings, booleans, or numbers are passed, try to add them together as best we can.			if (master is String) return master + slave.toString();			else if (master is Number) return Number(master) + Number(slave);			else if (master is Boolean) return Boolean(Number(master) + Number(slave));						// Loop through slave properties adding them to the master.			for(var i:String in slave)			{				// Declare variables.				var totalSkip:Number = skip.length;				var skipItem:Boolean = false;								// Check for skip properties.				for(var j:Number = 0; j < totalSkip; j++)				{					// If the current property is one of the properties to skip.					if (skip[ j ] == i)					{						// Set the skip boolean.						skipItem = true;												// Stop this loop.						break;					}				}								// If we need to skip this property.				if (skipItem)					// Continue to the next iteration of the loop so that the property is not set.					continue;								// If the property exists already and we do not want to overwrite it.				if (master[ i ] != null && !overwrite)					// Continue to the next iteration of the loop so that the property is not set.					continue;								// If this property is an object/array but not a movieclip.				if ((slave[ i ] is Object || slave[ i ] is Array) && !(slave[ i ] is DisplayObjectContainer))				{					// Add the empty object/array from which to start.					master[ i ] = (slave[ i ] is Array) ? [] : {};										// Recursively copy all of its properties so that we don't have any pointers.					master[ i ] = ObjectUtil.concat(master[ i ], slave[ i ], overwrite, skip);				}				else 					// Add from slave to master.					master[ i ] = slave[ i ];			}						// If the toString functionality has not been extended for this object, swap the toString functions.			if (master.toString() == "[object Object]" && slave.toString() != "[object Object]")				master = slave;						return master;		}		/**		 * Adds multiple properties to an object and all child objects if there are any.		 *		 * @param object			the object upon which to work		 * @param props			a list of name/value pairs to add (ex: [ ["name", "value"], ["name", "value"], ... ]).		 * @param overwrite			[Optional] true = overwrite property values if the property already exists on the object. false = (default) do not overwrite properties that already exist on the object.		 * @return Object.		 * @use	   {@code var addProperties:Object = ObjectUtil.addProperties(myObject, vArray, false);}		 */		public static function addProperties(object:Object, props:Array, overwrite:Boolean):Object		{			// Declare variables.			var total:Number = props.length;						// Loop through the properties to add, making copies on the target object and add property to all nested objects.			for(var k:Number = 0; k < total; k++) ObjectUtil.inheritProperty(object, props[ k ][ 0 ], props[ k ][ 1 ], overwrite);						// Return the copy.			return object;		}				/**		 * Adds a property to an object and all child objects if there are any.		 *		 * @param object			the object upon which to work.		 * @param prop				the name of the property to add.		 * @param value			the value of the property to add.		 * @param overwrite	 	[Optional] true = overwrite property values if the property already exists on the object. false = (default) do not overwrite properties that already exist on the object.		 * @return Object.		 * @use    {@code var inheritProperty:Object = ObjectUtil.inheritProperty(myObject, "id", id, true);}		 */		public static function inheritProperty(object:Object, prop:String, value:Object, overwrite:Boolean):Object		{			// If strings, booleans, or numbers are passed, try to add them together as best we can.			if (typeof object == "string") return object + value.toString();			else if (typeof object == "number") return Number(object) + Number(value);			else if (typeof object == "boolean") return Boolean(Number(object) + Number(value));						// Get all properties of the array			for(var i:String in object)			{				// If this element in the object/array is an object/array... recursively copy all of its properties so that we don't have any pointers.				if (Object(object[ i ]) != null) object[ i ] = ObjectUtil.inheritProperty(object[ i ], prop, value, overwrite);			}						// If the property doesn't already exist on the object and we wish to overwrite it... add it			if (object[ prop ] == null && overwrite) object[ prop ] = value;						// Return the copy.			return object;		}				/**		 * Creates a list of name/value pairs representing the properties of a source object where all of its properties are strings/numbers/booleans. 		 * The output array looks like: [ ["name", "value], ["name", "value"], ... ].		 * 		 * @param source			the object from which to pull data		 * @param collection 		an object to which to add properties (use an empty object to start this function off).		 * @param restricted		[Optional] a list of restricted data that should not be added to the request object.		 * @return Object.		 * @use	   {@code var propList:Array = ObjectUtil.minePropertiesList(myObject, "id");}		 */		public static function minePropertiesList(source:Object, vRestrict:Array):Array		{			// Build an object with all of the properties on the data object except a restricted list.			var propsObj:Object = ObjectUtil.mineProperties(source, {}, vRestrict);						// Declare variables.			var propsArray:Array = [];			var k:Number = 0;						// Build a list from the object with all of the props data.			for(var j:String in propsObj)			{				// Add the property name and value into the array of properties.				propsArray[ k ] = [ j, propsObj[ j ] ];								// Increment.				++k;			}			// Return the newly created array.			return propsArray;		}				/**		 * Creates an object where all of its properties are strings/numbers/booleans farmed from a source object that may have other nested objects/arrays.		 * 		 * @param source			the object from which to pull data.		 * @param collection		an object to which to add properties (use an empty object to start this function off).		 * @param restricted		[Optional] a list of restricted data that should not be added to the request object.		 * @return Object.		 * @use	   {@code var propList:Object = ObjectUtil.mineProperties(myObject, "id");}		 */		public static function mineProperties(source:Object, collection:Object, restricted:Array):Object		{			// Loop through the properties in the source object adding to the collection object.			for(var i:String in source)			{				// If the current property is an object.				if (Object(source[ i ]))					// Recursively add all of this object's properties...					collection = ObjectUtil.mineProperties(source[ i ], collection, restricted);					// Otherwise, make sure that this is not a restricted property.				else				{					// Declare variables					var isStopped:Boolean = false;					var total:Number = restricted.length;										// Make sure that this property is not restricted.					for(var j:Number = 0; j < total; j++)					{						// If the current property is restricted...						if (restricted[ j ] == i)						{							// Remember to stop the outer loop.							isStopped = true;														// Break this loop.							break;						}					}					// If this property was not restricted and it doesn't already exist (specicifity), add it to the request object.					if (!isStopped && (collection[ i ] == null)) collection[ i ] = source[ i ];				}			}			// Return the populated request object.			return collection;		}				/**		 * Gets all of the first level objects that are properties of the specified object (ie. get all objects out of this object).		 * 		 * @param master		the object to farm.		 * @param skip			a list of properties that should be skipped.		 * @return Array.		 * @use	   {@code var objArray:Array = ObjectUtil.mineObjects(myObject, false, [ "id", "area" ]);}		 */		public static function mineObjects(master:Object, skip:Array):Array		{			// Declare variables			var skipLength:Number = skip.length;			var list:Array = [];						// Loop through the master object looking for properties that are not numbers, strings, booleans, or arrays.			for (var i:String in master)			{				// Declare variables.				var shouldContinue:Boolean = false;								// If there are any properties to skip.				if (skipLength > 0)				{					// Search through the skip array to see if the current property should be skipped.					for(var j:Number = 0; j < skipLength; j++)					{						// If this property should be skipped, continue with the outer loop.						if (skip[ j ] == i)						{							shouldContinue = true;							break;						}					}				}								// If we should be skipping this property.				if (shouldContinue) continue;								// If this property is an object...				if (master[ i ] is Array)				{					// Get any objects inside of this array.					var total:Number = master[ i ].length;					for(var h:Number = 0; h < total; h++)					{						// If this is an object, add it to the array...						if (master[ i ][ h ] is Object)							list.push(master[ i ][ h ]);					}				}					// Save it to the list.				else if (typeof master[ i ] == "object")					list.push(master[ i ]);			}			// Return the list			return list;		}				/**		 * Determines if something is a single object or if it is a list of objects and returns out of that		 * object/list the object that contains the property with optionally matching value		 * 		 * @param data			the object on which you expect the property to exist.		 * @param property		the property that you which to check for.		 * @param value			[Optional] the value to which you wish to limit property.		 * @param matches	 	[Optional] true = (default) find objects that have the requested property and property value, false = find objects that do not have the requested property and property value.		 * @return Array.		 * @use	   {@code var propArray:Array = ObjectUtil.findByProperty(myObject, "id", 260, true);}		 *		 *	@usageNote		If you're looking to return all values that DO NOT have the property at all, set value to NULL and match to false.		 */		public static function findByProperty(data:Array, property:String, value:Number = 0, matches:Boolean = true):Array		{			if(data != null)			{				// Declare variables.				var test:Boolean;				var list:Array = [];				var array:Array = new Array(data);				var object:Object = Object(data);								// If data is an array.				if (array != null)				{					// Declare variables.					var total:Number = data.length;										// Loop through the array searching for the requested property.					for(var i:Number = 0; i < total; i++)					{						// Declare variables.						var current:Object = data[i];												// Test the property.						test = ObjectUtil.testProperty(current, property, value);												// If it tested true and we want to save objects with matching properties,						// or if it tested false and we want to save objects without matching properties add it to the array of matching data.						if ((test && matches) || (!test && !matches)) list.push(current);					}				}					// Otherwise, if the data is an object				else if (object != null)				{					// Test the property.					test = ObjectUtil.testProperty(data, property, value);										// If it tested true and we want to save objects with matching properties,					// or if it tested false and we want to save objects without matching properties add it to the array of matching data.					if ((test && matches) || (!test && !matches)) list.push(data);				}				else				{					trace("Invalid Data Type: The data object being searched through must be an object or an array.");					return null;				}				// Send back the list of matching properties.				return list;			}						return null;			}				/**		 * Compare two objects to see if they are identical. 		 * This is a recursive function so all nested objects/arrays will also be tested.		 *		 * @param master		object upon which to work.		 * @param slave		object we're comparing to.		 * @return Boolean.		 */		public static function identical(master:Object, slave:Object):Boolean		{			// If slave is a reference to master, they match.			if (master == slave) return true;						// Loop through the properties of this object, testing to see if they match.			for(var i:String in master)			{				// If one of the properties doesn't match, return false.				if (!testProperty(slave, i, master[ i ])) return false;			}						// If we got this far, everything matched.			return true;		}				/**		 * Determines if a property exists on an object 		 * and optionally if it has the correct value.		 * 		 * @param data			object on which you expect the property to exist.		 * @param property		property that you which to check for.		 * @param value		[Optional] the value to which you wish to limit property.		 * @return Boolean.		 */		public static function testProperty(data:Object, property:String, value:Number = 0):Boolean		{			// If the property exists.			if (data[ property ] != null)			{				// If a value to match was passed.				if (value != 0)				{					// If they match.					if (data[ property ] == value) return true;				}					// Otherwise.				else					// The property matches.					return true;			}						// If we got this far, the property does not match.			return false;		}	}}