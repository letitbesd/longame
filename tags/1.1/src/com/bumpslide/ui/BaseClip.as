/** * This code is part of the Bumpslide Library by David Knape * http://bumpslide.com/ *  * Copyright (c) 2006, 2007, 2008 by Bumpslide, Inc. *  * Released under the open-source MIT license. * http://www.opensource.org/licenses/mit-license.php * see LICENSE.txt for full license terms */ package com.bumpslide.ui {	import com.bumpslide.events.UIEvent;	import com.bumpslide.util.Delegate;	import com.longame.core.IDestroyable;	import com.longame.utils.ObjectUtil;	import com.longame.utils.Reflection;	import com.longame.utils.StringParser;	import com.longame.utils.debug.Logger;		import flash.display.DisplayObject;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.ColorTransform;	import flash.text.StaticText;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		import org.swiftsuspenders.Reflector;
	
	/**     * Base Class for MovieClips that just want access to the shortcut methods provided here.     *      * If your class is a component that needs a validation model for data and sizing,      * you should extend Component instead.     *      * @author David Knape     */    public class BaseClip extends Sprite implements IDestroyable	{		public var debugEnabled:Boolean = false;		protected var _skin:MovieClip;		/**		 * 以[Child(source="ch.ch1.item" state="normal")]为形式的元数据标签		 * */		protected var _skinMetas:Array;				private static const reflector:Reflector=new Reflector();				public function BaseClip() {			this.init();    	}			/**		 * MovieClip皮肤		 * */		public function get skin():MovieClip		{			return _skin;		}		final public function set skin(value:MovieClip):void		{			if(value==null){				throw new Error("Skin MovieClip is null!");			}			if(_skin==value) return;			this.destroySkin();			this._skin=value;			this._skin.stop();			this.parseSkin();		}		/**		 * Added to stage hook, called after init and addChildren 		 */		protected function onAddedToStage(event:Event):void 		{					}		protected function onRemoveFromStage(event:Event):void		{					}
		/**		 * 根据MovieClip皮肤和Child标签信息来解析		 *		[Child(source="mc1.mc2.okButton"]		 * 		public var button:LabelButton;		 * 上面表示一个LabelButton定义，source是skin里嵌套的原件，如上表示skin.mc1.mc2.okButton这个嵌套了3级的原件,它会作为button的skin，		 *  如果不指定source,则自动在skin里寻找名位buton的MovieClip作为button的skin		 *      [Child(source="mc1.labelTxt")]		 * 		public var label:TextField;		 * 上面表示将label指向skin.mc1.labelTxt这个文本框，当然还可以是任何flash的原生显示类，这样在程序里不用一个劲的点来点去的了		 *      [Child(source="item",state="normal"]		 * 		public var normalButton:LabelButton;		 * 		[Child(source="item",state="locked"]		 * 		public var lockedButton:LabelButton;		 * 上面使用了标签的state属性，表示skin会有normal和locked两帧，每帧都放了一个可作为LabelButton皮肤的MC，名字都叫item，这样这个ui组件		 * 就可以有normal和locked两种状态了,详见set state()		 * 注意：		 * 1. Child标签里可以设定任何组件所具有的属性，如下定义一个按钮，为选中状态，当定义属性的规则可见StringParser		 * 	   [Child(selected="true")]		 *     public var button:Button;		 * 2. skinMc里需要转换成Component的，不要有动画，一定要有动画将其放置到空容器中，让空容器动；		 * 3. 不要将要转成Component的对象和遮罩和一些图形放在以起，出了问题查这个		 */    	private function parseSkin():void		{			//将loader排除，因为单独的swf加载后parent就是loader			if(this._skin.parent&& !(this._skin.parent is Loader)) {				//将this添加到skinMC父亲的相应层级				var index:int=this._skin.parent.getChildIndex(this._skin);				this._skin.parent.addChildAt(this,index);			}			//然后将skinMC添加到this中，如此则skinMC保证了位置和层次的一致性			this.addChild(_skin);			//解析Skin标签			_skinMetas=Reflection.getMetaInfos(this,"Child");			var type:Class;			for each(var skinInfo:* in _skinMetas){				if(skinInfo.state){					//如果有状态组件且不是当前状态的，忽略之					if(_state!=skinInfo.state) continue;				}				//获取有source指定的原件做child的skin				var childSkin:DisplayObject=this.getSkinChildSource(skinInfo);				if(childSkin==null) {				    Logger.error(this,"parseSkin","No source with name: "+(skinInfo.source||skinInfo.varName)+" in skin!");					continue;				}				//根据childSkin创建对于的child组件				this.createSkinChild(skinInfo,childSkin);				//可能的话，将data配置给对应状态的child				if(_data&&skinInfo.state&&(_state==skinInfo.state)) this[skinInfo.varName].data=_data;			}			this.whenSkinned();		}		private function createSkinChild(skinInfo:*,skin:DisplayObject):void		{			var type:Class=getDefinitionByName(skinInfo.varClass) as Class;			//如果skinPart和source是同一类型的元件，则直接赋值就可以了，否则视为ui元件，传入skinMC			if(reflector.classExtendsOrImplements(type,BaseClip)){				this[skinInfo.varName]=new type() as BaseClip;				this[skinInfo.varName].skin=skin;				//将name设为变量名				this[skinInfo.varName].name=skinInfo.varName;			}else{				this[skinInfo.varName]=skin;			}			//解析可能的预定义属性,source和state属性除外			ObjectUtil.cloneProperties(skinInfo,this[skinInfo.varName],["source","state"]);			this.whenSkinChildCreated(this[skinInfo.varName]);//			Logger.info(this,"createSkinChild","Create skin child: "+skinInfo.varName);		}		/**		 * 根据meta的source信息获取子元素的skin源		 * */		private function getSkinChildSource(skinInfo:*):DisplayObject		{			var source:DisplayObject=this._skin;			var sourcePath:String=skinInfo.source;			//如果没有指定source属性，则取skinMC下同名的元件			if(sourcePath==null) sourcePath=skinInfo.varName;			//sourcePath允许多级嵌套，但其根目标是skinMC			var sarr:Array=sourcePath.split(".");			var len:int=sarr.length;			for(var i:int=0;i<len;i++){				source=source[sarr[i]];			}			return source;		}		protected var _skinned:Boolean;		/**		 * skin解析完毕，子类覆盖处理		 * */		protected function whenSkinned():void		{			_skinned=true;		}		/**		 * 当某个标签child创建		 * */		protected function whenSkinChildCreated(child:DisplayObject):void		{					}		protected var _prevState:String;		protected var _state:String;		/**		 * 组件的状态，对于mc做皮肤的ui，一个state对应一帧		 * */		public function get state():String		{			return _state;		}		final public function set state(value:String):void		{			if(_state==value) return;			_prevState=_state;			_state=value;			if(_skin) this.updateStateChildren();			this.whenStateChanged();		}		private function updateStateChildren():void		{			//然后将皮肤走到_state那帧			_skin.gotoAndStop(_state);			for each(var skinInfo:* in _skinMetas){				//无状态指示的不管				if(skinInfo.state==null) continue;				//销毁非此状态的组件				if(skinInfo.state!=_state){					if(this[skinInfo.varName]&&(this[skinInfo.varName] is BaseClip)) {						(this[skinInfo.varName] as BaseClip).destroy();						this[skinInfo.varName]=null;					}					//创建此状态的组件				}else{					var childSkin:DisplayObject=this.getSkinChildSource(skinInfo);					if(childSkin==null) {						Logger.error(this,"set state","No source with name: "+(skinInfo.source||skinInfo.varName)+" in skin!");						continue;					}					this.createSkinChild(skinInfo,childSkin);				}			}			this.whenSkinned();		}		/**		 * 状态改变时处理		 * */		protected function whenStateChanged():void		{					}		protected var _data:*;		/**		 * 自定义数据		 * */		public function get data():*		{			return _data;		}		final public function set data(value:*):void		{			if((_data==value)&&this.isSimpleValue(value)) return;			_data=value;			for each(var skinInfo:* in _skinMetas){				//将数据赋给当前state的child				if((skinInfo.state==null)||(skinInfo.state!=_state)) continue;				this[skinInfo.varName].data=_data;			}			this.whenDataChanged();		}		private function isSimpleValue(value:*):Boolean		{			if((value==undefined)||(value==null)) return false;			var type:String=typeof(value);			return (type=="number")||(type=="string")||(type=="boolean");		}		/**		 * 数据改变时更新		 * */		protected function whenDataChanged():void		{					}		/**		 * Displays object as "[Classname:instanceName]"		 */		override public function toString():String {			var classname:String = getQualifiedClassName(this).split('::').pop();						return "["+classname+":"+name+"]";		}				/**		 * Initialize		 */		protected function init() : void {			addEventListener( Event.ADDED_TO_STAGE, onAddedToStage, false, 0, true);			addEventListener( Event.REMOVED_FROM_STAGE, onRemoveFromStage, false, 0, true);		}    	/**    	 * Destroy    	 */		protected var _destroyed:Boolean;    	final public function destroy() : void {    		if(_destroyed) return;			_destroyed=true;			this.doDestroy();    	}		public function get destroyed():Boolean		{			return _destroyed;		}		protected function doDestroy():void		{			_data=null;			this.destroySkin();			var child:DisplayObject;			while(this.numChildren){				child=this.getChildAt(0);				if(child is IDestroyable) (child as IDestroyable).destroy();				if(child.parent) child.parent.removeChild(child);			}			if(this.parent) this.parent.removeChild(this);		}    	private function destroySkin():void		{			if(this._skin&&this._skin.parent) this._skin.parent.removeChild(this._skin);			for each(var skinInfo:* in _skinMetas){				if(this[skinInfo.varName]==null) continue;				if(this[skinInfo.varName] is BaseClip) (this[skinInfo.varName] as BaseClip).destroy();				this[skinInfo.varName]=null;			}			this._skinMetas=null;			this._skin=null;			this._skinned=false;		}		/**		 * Dispatches a UIEvent which is a bubbling event with a data holder		 */		protected function sendEvent( type:String, data:Object=null ) : void {			UIEvent.send( this, type, data );		}						/**		 * Delegate that swallows input (like an event or some callback info) and calls your delegate		 * 		 * This is seful for cases where an event should trigger an existing function.		 * 		 * Example:		 *   my_btn.addEventListener( MouseEvent.CLICK, Link.to, "http://yahoo.com/" );		 * 		 */		protected function eventDelegate( func:Function, ...args ) : Function {			var delegate:Function = Delegate.create.apply( null, [func].concat(args) );			return function (...rest) : void { delegate.call(); };		}			/**		 * Safely remove child (no errors) and call its destroy method if it has one		 */		protected function destroyChild( child:DisplayObject ):void {			if(child!=null) {				if (child is BaseClip) {				 	(child as BaseClip).destroy();				}				if (child.parent!=null) {					child.parent.removeChild(child);				}			}		}				/**		 * changes the color of a movieclip		 */		protected function colorize( mc:DisplayObject, color:uint ) : void {			var current_alpha:Number = mc.alpha;			if(isNaN(color)) {				mc.transform.colorTransform = null;			} else {				var ct:ColorTransform = new ColorTransform();				ct.color = color;				mc.transform.colorTransform = ct;			}			mc.alpha = current_alpha;		}				/**		 * Trace		 */		protected function debug( s:* ) : void {			if(debugEnabled) trace( this + ' ' + s );		}				//-------------------------------		// shortcuts to Delegate methods		//--------------------------------		   		protected var d:Function = Delegate.create; 	    	protected var delegate:Function = Delegate.create;    	protected var callLater:Function = Delegate.callLater;		protected var cancelCall:Function = Delegate.cancel;    }}