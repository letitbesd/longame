package com.longame.commands.base{	import com.longame.commands.base.Command;
	/**	 * A CompositeCommand is a composite command that consists of several single	 * commands which are executed in sequential order.	 * 	 * @author longyangxi	 */		public class SerialCommand extends CompositeCommand	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////		/** @private */		protected var _currentCommand:Command;		/** @private */		protected var _currentMsg:String;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new CompositeCommand instance.		 */		public function SerialCommand(delay:uint=0,timeOut:uint=999999,retryCount:uint=0)		{			super(delay,timeOut,retryCount);		}		public function get currentCommand():Command		{			return _currentCommand;		}				/**		 * Executes the composite command. Abstract method. Be sure to call super.execute()		 * first in subclassed execute methods.		 */ 		override protected function doExecute():void		{			super.doExecute();			next();		}						/**		 * Aborts the command's execution.		 */		override public function abort():void		{			super.abort();			if (_currentCommand) _currentCommand.abort();		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * The name identifier of the command.		 */		override public function get name():String		{			return "serialCommand";		}				/**		 * The Message associated to the command's progress.		 */		override public function get progressMsg():String		{			if(_currentMsg) return _currentMsg;			return _currentCommand.progressMsg;		}		////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////		/**		 * Executes the next enqueued command.		 * @private		 */		override protected function next(oldcommand:Command=null):Boolean		{		     var hasNext:Boolean=super.next(oldcommand);			 if(!hasNext) return false;			_currentMsg = _messages.shift();			_currentCommand = _commands.shift();			_currentCommand.addListener(this);			_currentCommand.execute();			return true;		}		/**		 * @private		 */		override protected function complete():void		{			_currentCommand = null;			_currentMsg = null;			super.complete();		}	}}